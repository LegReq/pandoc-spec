<!DOCTYPE html>
<html$if(lang)$ lang="$lang$"$endif$$if(dir)$ dir="$dir$"$endif$>
<head>
    <!-- These tags must come first. -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="generator" content="Pandoc Specification Builder">

    $for(author-meta)$
    <meta name="author" content="$author-meta$" />
    $endfor$
    $if(date-meta)$
    <meta name="dcterms.date" content="$date-meta$" />
    $endif$
    $if(keywords)$
    <meta name="keywords" content="$for(keywords)$$keywords$$sep$, $endfor$" />
    $endif$
    $if(description-meta)$
    <meta name="description" content="$description-meta$" />
    $endif$
    <title>$if(title-prefix)$$title-prefix$ – $endif$$pagetitle$</title>

    <!-- Includes Bootstrap CSS. -->
    <link rel="stylesheet" href="pandoc-spec.css" />

    $if(quotes)$
    <style>q { quotes: "“" "”" "‘" "’"; }</style>
    $endif$

    $if(highlighting-css)$
    <style>$highlighting-css$</style>
    $endif$

    $for(css)$
    <link rel="stylesheet" href="$css$" />
    $endfor$

    $if(math)$
    $math$
    $endif$

    $for(header-includes)$
    $header-includes$
    $endfor$
</head>

<body>
    <div id="_container" class="container$container-style$">
        <div id="_header" class="header$header-style$">
            $for(include-before)$
            $include-before$
            $endfor$
        </div>

        <div id="_body" class="body$body-style$">
            $if(toc)$
            <!-- Table of contents will move to the top below breakpoint. -->
            <div id="_toc" class="toc$toc-style$">
                $if(toc-header)$
                <header><span class="toc-header">$toc-header$</span></header>
                $endif$
                $toc$
            </div>
            $endif$
            <main id="_content" class="content$content-style$">
                $body$
            </main>
        </div>

        <div id="_footer" class="footer$footer-style$">
            $for(include-after)$
            $include-after$
            $endfor$
        </div>
</div>

<!-- JQuery -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

<!-- Bootstrap -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>

<!-- AnchorJS -->
<script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script>

<!-- LemonadeJS JavaScript Tabs -->
<script src="https://cdn.jsdelivr.net/npm/lemonadejs/dist/lemonade.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@lemonadejs/tabs/dist/index.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@lemonadejs/tabs/dist/style.min.css" />

<script>
    document.addEventListener("DOMContentLoaded", () => {
        // Add anchors to all headings (default excludes h1), except for those with class "unlisted".
        anchors.add("h1, h2, h3, h4, h5, h6").remove(".unlisted");

        if ("scrollRestoration" in history) {
            // Signal that scroll restoration is handled manually.
            history.scrollRestoration = "manual";
        }

        // Get all scrollable elements.
        const bodyElement = document.getElementById("_body");
        const tocElement = document.getElementById("_toc");
        const contentElement = document.getElementById("_content");

        function saveScroll() {
            // Update the state in history with the current scroll positions.
            history.replaceState({
                bodyTop: bodyElement.scrollTop,
                bodyLeft: bodyElement.scrollLeft,
                tocTop: tocElement.scrollTop,
                tocLeft: tocElement.scrollLeft,
                contentTop: contentElement.scrollTop,
                contentLeft: contentElement.scrollLeft
            }, "");
        }

        let timeout = setTimeout(saveScroll, 50);

        function resetTimeout() {
            clearTimeout(timeout);

            // Give user 50ms to settle scrolling.
            timeout = setTimeout(saveScroll, 50);
        }

        // Add scroll listener.
        bodyElement.addEventListener("scroll", resetTimeout);
        tocElement.addEventListener("scroll", resetTimeout);
        contentElement.addEventListener("scroll", resetTimeout);

        addEventListener("popstate", (e) => {
            const state = e.state;

            // Restore scroll positions if state object is the right type.
            if (typeof state === "object" && state !== null && "bodyTop" in state && "bodyLeft" in state && "tocTop" in state && "tocLeft" in state && "contentTop" in state && "contentLeft" in state) {
                bodyElement.scrollTo({
                    top: state.bodyTop,
                    left: state.bodyLeft
                });

                tocElement.scrollTo({
                    top: state.tocTop,
                    left: state.tocLeft
                });

                contentElement.scrollTo({
                    top: state.contentTop,
                    left: state.contentLeft
                });
            }
        });

        const location = self.location;

        // Override click behaviour for internal links.
        for (const link of document.getElementsByTagName("a")) {
            if (link.hash !== "" && link.origin === location.origin && link.pathname === location.pathname) {
                const targetElement = document.getElementById(link.hash.substring(1));

                if (targetElement !== null) {
                    const target = `$${location.origin}$${location.pathname}$${location.search}#$${targetElement.id}`;

                    link.addEventListener("click", (e) => {
                        // Add target to history.
                        history.pushState(null, "", target);

                        resetTimeout();

                        // Bring the target element into view and prevent default click behaviour.
                        targetElement.scrollIntoView(true);
                        e.preventDefault();
                    });
                }
            }
        }

        function processElements(parentElement, elements, i, enclosingLevel = 0, targetElement = null, headingCallback = null) {
            let done = elements === undefined;

            while (!done && i < elements.length) {
                const element = elements[i];

                const level = /[hH][1-6]/.test(element.tagName) ? Number(element.tagName.substring(1)) : 10;

                // Level less than or equal to enclosing level signals end of heading content.
                done = level <= enclosingLevel;

                // If done, index will be reprocessed by caller.
                if (!done) {
                    let specialHeading = false;

                    if (level !== 10) {
                        if (element.classList.contains("tabbed")) {
                            specialHeading = true;

                            // Remove so that it's processed as normal on next iteration.
                            element.classList.remove("tabbed");

                            let tabGroupElement = null;

                            processElements(parentElement, elements, i + 1, level, null, (siblingHeadingElement, siblingLevel, i) => {
                                // Anything between start of tab group and first tab remains unmodified.
                                if (tabGroupElement === null) {
                                    tabGroupElement = document.createElement("div");
                                    tabGroupElement.setAttribute("class", "tabbed");

                                    parentElement.insertBefore(tabGroupElement, siblingHeadingElement);
                                }

                                const tabElement = document.createElement("div");

                                // Copy classes except unnumbered and unlisted.
                                for (const classItem of siblingHeadingElement.classList) {
                                    if (classItem !== "unnumbered" && classItem !== "unlisted") {
                                        tabElement.classList.add(classItem);
                                    }
                                }

                                // Copy additional attributes.
                                [...siblingHeadingElement.attributes].forEach(({name, value}) => {
                                    // Class attribute is handled separately.
                                    if (name !== "class") {
                                        tabElement.setAttribute(name, value);
                                    }
                                });

                                tabElement.setAttribute("title", siblingHeadingElement.textContent);

                                // Replace heading element with tab element.
                                tabGroupElement.appendChild(tabElement);
                                parentElement.removeChild(siblingHeadingElement);

                                processElements(parentElement, elements, i + 1, siblingLevel, tabElement);
                            });
                        } else if (headingCallback !== null && level === enclosingLevel + 1) {
                            specialHeading = true;

                            headingCallback(element, level, i);
                        }
                    }

                    if (!specialHeading) {
                        // Processing the current element's child nodes doesn't advance the current index.
                        processElements(element, element.childNodes, 0);

                        if (targetElement !== null) {
                            targetElement.appendChild(element.cloneNode(true));
                            parentElement.removeChild(element);
                        } else {
                            i++;
                        }
                    }
                }
            }
        }

        processElements(document.body, document.body.childNodes, 0);

        for (const tabGroupElement of document.querySelectorAll("div.tabbed")) {
            Tabs(tabGroupElement);
        }
    });
</script>

</body>
</html>
